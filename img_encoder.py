#!/usr/bin/env python3
"""
Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ñ‹Ğ¹ ĞŸĞ¸ĞºÑĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº v2.0

Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ ÑƒÑĞ·Ğ²Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸:
âœ… Salt (16 Ğ±Ğ°Ğ¹Ñ‚) - Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ñ€Ğ°Ğ´ÑƒĞ¶Ğ½Ñ‹Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†
âœ… PBKDF2 (200000 Ğ¸Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹) - Ğ·Ğ°Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ¸Ğµ Ğ±Ñ€ÑƒÑ‚Ñ„Ğ¾Ñ€ÑĞ°  
âœ… Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ Nonce/IV (12 Ğ±Ğ°Ğ¹Ñ‚) - ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ‚Ğ¾Ğº Ğ¿Ñ€Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ¼ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ğµ
âœ… AES-256-GCM Ğ²Ğ¼ĞµÑÑ‚Ğ¾ ÑĞ°Ğ¼Ğ¾Ğ¿Ğ¸ÑĞ½Ğ¾Ğ³Ğ¾ XOR
âœ… Ğ’ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ğ°Ñ Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ (AEAD) - Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¸Ğµ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¹
âœ… Ğ”Ğ»Ğ¸Ğ½Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ±Ğ»Ğ¾ĞºĞ°
âœ… Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ padding - Ğ¼Ğ°ÑĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ°
"""

import math
import struct
import secrets
from PIL import Image
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from typing import Tuple, Optional

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    ĞšĞĞĞ¡Ğ¢ĞĞĞ¢Ğ« Ğ‘Ğ•Ğ—ĞĞŸĞĞ¡ĞĞĞ¡Ğ¢Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SALT_SIZE = 16              # Ğ¡Ğ¾Ğ»ÑŒ Ğ´Ğ»Ñ PBKDF2
NONCE_SIZE = 12             # IV Ğ´Ğ»Ñ AES-GCM (Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´ÑƒĞµĞ¼Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€)
KEY_SIZE = 32               # AES-256
PBKDF2_ITERATIONS = 200_000 # Ğ˜Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ (Ğ·Ğ°Ğ¼ĞµĞ´Ğ»ÑĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ ~0.5-1 ÑĞµĞº)
FORMAT_VERSION = 2          # Ğ’ĞµÑ€ÑĞ¸Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ° Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
MAX_PADDING = 256           # ĞœĞ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ÑĞ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ padding


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    ĞšĞ Ğ˜ĞŸĞ¢ĞĞ“Ğ ĞĞ¤Ğ˜Ğ§Ğ•Ğ¡ĞšĞ˜Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def derive_key(password: str, salt: bytes) -> bytes:
    """
    Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ° Ğ¸Ğ· Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ.
    
    PBKDF2-HMAC-SHA256:
    - Ğ—Ğ°Ğ¼ĞµĞ´Ğ»ÑĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ±Ğ¾Ñ€ Ğ¿Ğ°Ñ€Ğ¾Ğ»ĞµĞ¹ (~200k Ñ…ĞµÑˆĞµĞ¹ Ğ½Ğ° 1 Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºÑƒ)
    - Ğ¡Ğ¾Ğ»ÑŒ Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ğ±ĞµÑĞ¿Ğ¾Ğ»ĞµĞ·Ğ½Ñ‹Ğ¼Ğ¸ Ñ€Ğ°Ğ´ÑƒĞ¶Ğ½Ñ‹Ğµ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
    """
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=KEY_SIZE,
        salt=salt,
        iterations=PBKDF2_ITERATIONS,
    )
    return kdf.derive(password.encode('utf-8'))


def encrypt_data(data: bytes, password: str) -> bytes:
    """
    Ğ¨Ğ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ AES-256-GCM.
    
    Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° (Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¾):
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ VER (1) â”‚ SALT(16) â”‚ NONCE(12) â”‚ CIPHER_LEN (4) â”‚ CIPHERTEXT  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Ğ’Ğ½ÑƒÑ‚Ñ€Ğ¸ ciphertext (Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ + Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾):
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ DATA_LEN (4) â”‚ DATA (N) â”‚ RANDOM_PADDING (?) â”‚ TAG(16) â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ‹ Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
    salt = secrets.token_bytes(SALT_SIZE)
    nonce = secrets.token_bytes(NONCE_SIZE)
    key = derive_key(password, salt)
    
    # Ğ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ñ‹Ğ¹ padding Ğ¼Ğ°ÑĞºĞ¸Ñ€ÑƒĞµÑ‚ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    padding_size = secrets.randbelow(MAX_PADDING)
    inner_data = (
        struct.pack('<I', len(data)) +  # Ğ”Ğ»Ğ¸Ğ½Ğ° (Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ°!)
        data + 
        secrets.token_bytes(padding_size)
    )
    
    # AES-GCM: ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ + Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾
    aesgcm = AESGCM(key)
    ciphertext = aesgcm.encrypt(nonce, inner_data, None)  # Ğ’ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ 16-Ğ±Ğ°Ğ¹Ñ‚ Ñ‚ĞµĞ³
    
    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ğ¿Ğ°ĞºĞµÑ‚
    return (
        struct.pack('<B', FORMAT_VERSION) +
        salt +
        nonce +
        struct.pack('<I', len(ciphertext)) +
        ciphertext
    )


def decrypt_data(encrypted: bytes, password: str) -> Tuple[Optional[bytes], Optional[str]]:
    """
    Ğ Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ° Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ Ñ†ĞµĞ»Ğ¾ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸.
    
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚:
        (Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, None) - ÑƒÑĞ¿ĞµÑ…
        (None, ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ_Ğ¾Ğ±_Ğ¾ÑˆĞ¸Ğ±ĞºĞµ) - Ğ¾ÑˆĞ¸Ğ±ĞºĞ°
    """
    # ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€: Ğ²ĞµÑ€ÑĞ¸Ñ + ÑĞ¾Ğ»ÑŒ + nonce + Ğ´Ğ»Ğ¸Ğ½Ğ° + Ñ‚ĞµĞ³
    min_size = 1 + SALT_SIZE + NONCE_SIZE + 4 + 16
    if len(encrypted) < min_size:
        return None, "Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğµ Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ²Ñ€ĞµĞ¶Ğ´ĞµĞ½Ñ‹"
    
    # ĞŸĞ°Ñ€ÑĞ¸Ğ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº
    version = encrypted[0]
    if version != FORMAT_VERSION:
        if version == 0 or version == 1:
            return None, "Ğ¤Ğ°Ğ¹Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½ ÑÑ‚Ğ°Ñ€Ğ¾Ğ¹ Ğ²ĞµÑ€ÑĞ¸ĞµĞ¹ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñ‹ (Ğ½ĞµÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾)"
        return None, f"ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ°: {version}"
    
    offset = 1
    salt = encrypted[offset:offset + SALT_SIZE]; offset += SALT_SIZE
    nonce = encrypted[offset:offset + NONCE_SIZE]; offset += NONCE_SIZE
    ciphertext_len = struct.unpack('<I', encrypted[offset:offset + 4])[0]; offset += 4
    
    if offset + ciphertext_len > len(encrypted):
        return None, "ĞŸĞ¾Ğ²Ñ€ĞµĞ¶Ğ´Ñ‘Ğ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº: ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ°Ñ Ğ´Ğ»Ğ¸Ğ½Ğ° Ğ¿Ñ€ĞµĞ²Ñ‹ÑˆĞ°ĞµÑ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
    
    ciphertext = encrypted[offset:offset + ciphertext_len]
    
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ»ÑÑ‡ (Ğ·Ğ°Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ ~0.5 ÑĞµĞº)
    key = derive_key(password, salt)
    
    try:
        # Ğ Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ° + Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°ÑƒÑ‚ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸
        aesgcm = AESGCM(key)
        inner_data = aesgcm.decrypt(nonce, ciphertext, None)
        
        # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
        if len(inner_data) < 4:
            return None, "Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: ÑĞ»Ğ¸ÑˆĞºĞ¾Ğ¼ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºĞ¸Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"
            
        data_len = struct.unpack('<I', inner_data[:4])[0]
        
        if data_len > len(inner_data) - 4:
            return None, "Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°: Ğ½ĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ´Ğ»Ğ¸Ğ½Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"
        
        return inner_data[4:4 + data_len], None
        
    except Exception:
        # GCM Ğ½Ğµ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€ÑƒĞµÑ‚ ĞµÑĞ»Ğ¸ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ Ğ½ĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ˜Ğ›Ğ˜ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ñ‹
        return None, "ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ Ğ¸Ğ»Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ²Ñ€ĞµĞ¶Ğ´ĞµĞ½Ñ‹/Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ñ‹"


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    Ğ ĞĞ‘ĞĞ¢Ğ Ğ¡ Ğ˜Ğ—ĞĞ‘Ğ ĞĞ–Ğ•ĞĞ˜Ğ¯ĞœĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def encode_data_to_image(data_bytes: bytes, password: str, output_filename: str = "encoded.png"):
    """Ğ£Ğ¿Ğ°ĞºĞ¾Ğ²ĞºĞ° Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ² PNG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ."""
    
    print("ğŸ” Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ° (ÑÑ‚Ğ¾ Ğ·Ğ°Ğ¹Ğ¼Ñ‘Ñ‚ ~1 ÑĞµĞº)...")
    encrypted = encrypt_data(data_bytes, password)
    
    # Ğ Ğ°ÑÑ‡Ñ‘Ñ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ğ° ĞºĞ²Ğ°Ğ´Ñ€Ğ°Ñ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ
    total_bytes = len(encrypted)
    required_pixels = math.ceil(total_bytes / 3)
    side = int(math.ceil(math.sqrt(required_pixels)))
    
    if side > 2000:
        print(f"âš ï¸  ĞŸÑ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğµ: Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ {side}x{side} Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ ÑĞ¶Ğ°Ñ‚ Ğ¼ĞµÑÑĞµĞ½Ğ´Ğ¶ĞµÑ€Ğ°Ğ¼Ğ¸!")
    
    # Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ğº Ğ¡Ğ›Ğ£Ğ§ĞĞ™ĞĞ«ĞœĞ˜ Ğ±Ğ°Ğ¹Ñ‚Ğ°Ğ¼Ğ¸ (Ğ½Ğµ Ğ½ÑƒĞ»ÑĞ¼Ğ¸ - Ğ¼Ğ°ÑĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°)
    padding_size = side * side * 3 - total_bytes
    full_data = encrypted + secrets.token_bytes(padding_size)
    
    # Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸ RGB
    pixels = [
        (full_data[i], full_data[i+1], full_data[i+2]) 
        for i in range(0, len(full_data), 3)
    ]
    
    img = Image.new('RGB', (side, side))
    img.putdata(pixels)
    img.save(output_filename, "PNG", compress_level=9)
    
    print(f"âœ… Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾: {output_filename}")
    print(f"   Ğ Ğ°Ğ·Ğ¼ĞµÑ€: {side}Ã—{side} Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹")
    print(f"   Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ: {len(data_bytes)} â†’ {len(encrypted)} Ğ±Ğ°Ğ¹Ñ‚ (Ğ·Ğ°ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾)")


def decode_data_from_image(image_path: str, password: str) -> Tuple[Optional[bytes], Optional[str]]:
    """Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· PNG Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ."""
    
    try:
        img = Image.open(image_path).convert('RGB')
    except FileNotFoundError:
        return None, f"Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {image_path}"
    except Exception as e:
        return None, f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ: {e}"
    
    # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ Ğ±Ğ°Ğ¹Ñ‚Ñ‹ Ğ¸Ğ· Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹
    raw_bytes = bytearray()
    for pixel in img.getdata():
        raw_bytes.extend(pixel[:3])  # Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ RGB, Ğ¸Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ°Ğ»ÑŒÑ„Ğ°-ĞºĞ°Ğ½Ğ°Ğ»
    
    print("ğŸ” Ğ Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²ĞºĞ° (ÑÑ‚Ğ¾ Ğ·Ğ°Ğ¹Ğ¼Ñ‘Ñ‚ ~1 ÑĞµĞº)...")
    return decrypt_data(bytes(raw_bytes), password)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                    Ğ˜ĞĞ¢Ğ•Ğ Ğ¤Ğ•Ğ™Ğ¡ ĞšĞĞœĞĞĞ”ĞĞĞ™ Ğ¡Ğ¢Ğ ĞĞšĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print("â•" * 55)
    print("  ğŸ”’ Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ½Ñ‹Ğ¹ ĞŸĞ¸ĞºÑĞµĞ»ÑŒĞ½Ñ‹Ğ¹ ĞšĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ñ‰Ğ¸Ğº v2.0")
    print("     AES-256-GCM â”‚ PBKDF2 â”‚ Salt â”‚ Nonce")
    print("â•" * 55)
    
    print("\n[1] Ğ—Ğ°ĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ² Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ")
    print("[2] Ğ Ğ°ÑĞºĞ¾Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸Ğ· Ğ¸Ğ·Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ")
    mode = input("\nĞ’Ñ‹Ğ±Ğ¾Ñ€: ").strip()

    if mode == "1":
        # === ĞšĞĞ”Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ===
        print("\nâ”Œâ”€ Ğ¢Ğ¸Ğ¿ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
        print("â”‚ [1] Ğ¢ĞµĞºÑÑ‚                    â”‚")
        print("â”‚ [2] Ğ¤Ğ°Ğ¹Ğ» (Ğ»ÑĞ±Ğ¾Ğ¹)             â”‚")
        print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        type_choice = input("Ğ’Ñ‹Ğ±Ğ¾Ñ€: ").strip()
        
        if type_choice == "2":
            file_path = input("ğŸ“ ĞŸÑƒÑ‚ÑŒ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ: ").strip().strip('"\'')
            try:
                with open(file_path, 'rb') as f:
                    data = f.read()
                print(f"   Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾: {len(data):,} Ğ±Ğ°Ğ¹Ñ‚")
            except FileNotFoundError:
                print("âŒ Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!")
                return
            except Exception as e:
                print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
                return
        else:
            text = input("ğŸ“ Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ñ‚ĞµĞºÑÑ‚: ")
            data = text.encode('utf-8')
            print(f"   Ğ Ğ°Ğ·Ğ¼ĞµÑ€: {len(data):,} Ğ±Ğ°Ğ¹Ñ‚")

        password = input("ğŸ”‘ ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ (Enter = ÑĞ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ): ").strip()
        if not password:
            password = secrets.token_urlsafe(16)
            print(f"\n   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
            print(f"   â•‘ Ğ¡Ğ“Ğ•ĞĞ•Ğ Ğ˜Ğ ĞĞ’ĞĞĞĞ«Ğ™ ĞŸĞĞ ĞĞ›Ğ¬:          â•‘")
            print(f"   â•‘ {password:<32} â•‘")
            print(f"   â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
            print("   âš ï¸  Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ Ğ¿Ğ°Ñ€Ğ¾Ğ»ÑŒ! Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾!\n")
        
        out_name = input("ğŸ’¾ Ğ˜Ğ¼Ñ Ñ„Ğ°Ğ¹Ğ»Ğ° (Enter = encoded.png): ").strip()
        if not out_name:
            out_name = "encoded.png"
        if not out_name.lower().endswith('.png'):
            out_name += '.png'
            
        encode_data_to_image(data, password, out_name)

    elif mode == "2":
        # === Ğ”Ğ•ĞšĞĞ”Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ• ===
        path = input("ğŸ–¼ï¸  ĞŸÑƒÑ‚ÑŒ Ğº ĞºĞ°Ñ€Ñ‚Ğ¸Ğ½ĞºĞµ: ").strip().strip('"\'')
        password = input("ğŸ”‘ ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ: ").strip()
        
        result_bytes, error = decode_data_from_image(path, password)
        
        if error:
            print(f"\nâŒ ĞĞ¨Ğ˜Ğ‘ĞšĞ: {error}")
            return
            
        print(f"\nâœ… Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾: {len(result_bytes):,} Ğ±Ğ°Ğ¹Ñ‚")
        
        print("\nâ”Œâ”€ Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° â”€â”€â”€â”€â”€â”€â”")
        print("â”‚ [1] ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ ĞºĞ°Ğº Ñ‚ĞµĞºÑÑ‚       â”‚")
        print("â”‚ [2] Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ñ„Ğ°Ğ¹Ğ»         â”‚")
        print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        save_mode = input("Ğ’Ñ‹Ğ±Ğ¾Ñ€: ").strip()
        
        if save_mode == "2":
            ext = input("ğŸ“„ Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ğ° (jpg/png/zip/pdf/...): ").strip().lstrip('.')
            save_path = f"restored.{ext}" if ext else "restored.bin"
            with open(save_path, 'wb') as f:
                f.write(result_bytes)
            print(f"ğŸ’¾ Ğ¤Ğ°Ğ¹Ğ» ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½: {save_path}")
        else:
            try:
                print("\n" + "â”€" * 40)
                print(result_bytes.decode('utf-8'))
                print("â”€" * 40)
            except UnicodeDecodeError:
                print("âŒ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ½Ğµ ÑĞ²Ğ»ÑÑÑ‚ÑÑ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼ UTF-8.")
                print("   Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ¾Ğ¿Ñ†Ğ¸Ñ [2] Ğ´Ğ»Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ² Ñ„Ğ°Ğ¹Ğ».")
    else:
        print("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ±Ğ¾Ñ€")


if __name__ == "__main__":
    main()
